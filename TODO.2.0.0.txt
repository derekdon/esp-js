2.0.0 update todos

[x] - Convert to tyepscript
[x] - makes observices of T, not t123
[x] - remove model changed event (fixed, or modified, not deleted)
[x] - remove all default exports
[x] - merge repos
[x] - rename all file types to lower case in esp-js
[x] - user generated .d.ts
[x] - expose single event subject for all events for a model
[x] - single publish step via lerna
[x] - polimer tests

// code changes
[x] - add support for pre and post processing to polimer states
      -How-to notes added in polimerModel.ts-
      - This isn't possible in a decent way.
      - Firstly it's only possible for handler objects as maps have no place to put pre/post processing and I'm not going to make up a convention
      - Secondly, you really want the pre/post hook to happe per state handler, however there could be multiple for a state so it's not deterministic which to call first
      - Thirdly, even if you didn't care about point 2, the router owns the observation stages do the polimer model only gets an onnext per event stage, it's cant
        own that process which is what's required. I.e. it needs to flip to imer before pre processing, call all handers for a related state, then post processing, then flip imer back.
        It can't do this as the knowledge of this is in the router.
        At the end of the day, the standard esp doesn't do this, so polimer doesn't need to.
        It does support an overall model pre and post hook like standard esp, that's sufficient.
        It could flip immer before calling that hook
[x] - add dynamic module loading to esp-js-ui
[ ] - verify examples (add catch-all tests if possible):
    - [ ] All should compile as part of build
    - [x] esp-js-api
    - [ ] esp-js-chat-react-es6
    - [ ] esp-js-di
    - [ ] esp-js-react-agile-board
    - [ ] esp-js-todomvc-react
    - [ ] esp-js-ui-module-based-app
[ ] - more elaborate esp-js-ui application
[ ] - shared test setups
[x] - bring micro-di-js under esp as esp-js-di
[ ] - Rx Js upgrade
[ ] - Add support to halt just a single model, but the model would need to opt in or be flagged explicitly for this functionality
[ ] - Lift Polimer state tracking to separate package so it can be swapped out
[x] - fix router.observeEventsOnWithDecorators_ES6_Tests.ts, some issues whereby babel isn't picking up the transpiled typescript.
      this should prob be an integration tests after the final package is built
[x] - rename 'store' to 'model' through out
    - there is API confusion as to what's a store and what's a model.
      In effect they are the same thing but the store is an immutable version.
      To simplify, and be consistent with existing naming, it should be 'model' through out.
      Will be much eaiser to document and the API will be way more consistent.
[x] - hide polimer model in the views
    - this can be done with a decorator but that decorator needs to be low level in esp as it's the only shared based, esp-js-react already depends on polimer
[x] - connectable component tests
[x] - remove model.lock() && model.unlock()
[x] - remove support for _observeEventsUsingConventions
[x] - remove support for model changed events
    - this isn't the best way to observe a change to a model, just use it's change stream, else more explicitly recognise your inter model dependencies
    - furthermore, with the newer single dispatch subject, there is no way to know which model will process an event, thus when .broadcast() is used, it's possible it ends up in an infinite loop due to needless model changed events getting dispatched
[x] - rename model.hasChange to model.receivedEvent as it doesn't really know if there wer changes, but rather that it received an event
[x] - clarify connect(), do we care about map publish to props and map model to props?
    - yes we need it, notes below. In effect it's a shorthand to allow you to connect a view of a different shape to a given model or store at any point in the vdom
[x] - Issue with the router not known which events the model is subscribed to thus will always dispatch broadcast events
    -- this problem exists for OO and polimer models and all event streams today as everything  build on the fat pipe.
    --- the modelRescord.haschanges is just set to true by default now so all broadcasts of events will make all models tick
    --- it would be possible to expose 'modelReord.isdirty' for leaf nodes to call, i.e. anything listening to an event observable
    --- however the pre and post process hooks still get called (bug since 1.0)
    ---- it would appear there needs to to be some more deterministic knowledge of which events are being observed and those
    ---- known to the router before the pre process hook is invoked.
    ---- this is no sensible way to know this as the fat pipe may or may not deliver to an ultimate observer based on filters in the obs stream
    ---- I;ve been back and forth on this, in the end I don't think there is an issue. If you use broadcast event it's an expensive operation
    ---- should shouldn't be used lightly. There is an edge case whereby the model changed event would fire, but that is to be removed leasing the impact

// build
[ ] - single travis build with lerna
[ ] - Ensure dependencies are exact versions

// misc
[ ] - push 'moved' checkins to esp-js-ui, esp-js-react, microdi-js
[ ] - write tests for examples to ensure they work after esp changes

// docs
[ ] - merge all readmes and restructure docs
[ ] - document monorepo setup
      - only binary (in node_modules/.bin) dev dependencies at package level
[ ] - document methods so the .d.ts have the docs
[ ] - document observeEventEnvelope
[ ] - Add Breaking Changes to release notes
[ ] - you ube videos to help with documents
[ ] - document all the new modules
[ ] - document router.broadcast being expensive
[ ] - good docs on ConnectableComponent and connect

// notes on esp-js-react's connect

    // connect allows you to adapt a model onto a view of a different shape, perhaps an existing view
    connect(
        (model, outerProps) => ({}), // takes the model and maps it to props to pass to the actual component you connect
        publishEvent1 => ({}) // takes a publish function to map to delegates to pass to the component you're about to connect
    )
    (null); // the component you're about to connect

    // you don't need to use conenct, you can just craft a top level view that will receive your model directly

    // even if you have a @viewBinging, you it will be ignored and you can connect a random component to the router using connect()


// breaking changes:
-  esp-js-ui modelselector removed
 - model changed event support
 - reactive api now pushes envelopes, not T1, T2, T3
 - .where renamed to .filter
 - lock and unlock removed
 - all default exports are now removed
 - Previously the typings exposed ModelObservable and EventObservable, however underthe covers there was only ever 1 javascript object 'Observable'.
   Now we're auto generating the types, all that exists is `Observable<T>`
 - Extending the observable API requires a bit of dancing as typescript doesn't seem to declaration merge correctly when the .d.ts files are in multiple files.
   It's the same patter as suggested here https://www.typescriptlang.org/docs/handbook/declaration-merging.html.
   However you need to declare the specific path of the .d.ts you're extending, rather than the root import 'esp-js':

     ```
        import * as Rx from 'rx';
        import {Observable } from 'esp-js';

        declare module 'esp-js/.dist/typings/reactive/observable' {
            export interface Observable<T> {
                toRxObservable?<T>(): Rx.Observable<T>;
            }
        }

        Observable.prototype.toRxObservable = function <T>(): Rx.Observable<T> {
            const source: Observable<T> = this;
            return Rx.Observable.create<T>(obs => {
                const subscription = source.subscribe(
                    (i: T) => obs.onNext(i),
                    () => obs.onCompleted()
                );
                return subscription;
            });
        };
     ```
 - fixed inconsistent usage of eventName/eventType, now eventType:string everywhere